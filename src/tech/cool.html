<!DOCTYPE html>
<!--suppress CheckEmptyScriptTag -->
<html lang="en">
<head>
    <title>Cool things I wish existed</title>
    <include src="/fragment/head.html" />
</head>
<body>

<include src="/fragment/nav.html" />

<main>

    <section>
        <h1><a id="imim" href="#imim">IMAP Instant Messenger</a></h1>
        One of the worst things about email is signatures and
        <a href="https://en.wikipedia.org/wiki/Salutation">salutations</a>.
        Another terrible thing is HTML content obscuring the actual message.
        Maybe we should strip email back to the bare minimum, make it real-time,
        and use it as a protocol for instant messaging. Of course, it would be
        backward compatible with email so you can still communicate with everyone
        you need to reach. But maybe some additional features are available when
        both sides are using IMAP Instant Messenger (IMIM). This would also fix
        the problem of the conversation not appearing linearly, partly due to
        the messed-up way that people format replies which is exacerbated by
        signatures and salutations.
    </section>

    <section>
        <h1><a id="imap-agent" href="#imap-agent">IMAP Agent</a></h1>
        What good is an email client that doesn't help you read any email?
        When I was listening to <a href="https://www.relay.fm/mpu/539">Mac Power
        Users #539 - Back to Email</a> I started thinking it might be super useful
        to have a stripped down IMAP client where the sole purpose is executing
        rules (filtering, etc.). Sure, Gmail gives you the ability to perform some
        basic filtering, but you can't do any complex operations. You can't even
        unconditionally forward email! Imagine having much more power, extensible
        with local programming and shell scripts. Being able to run it in AWS ECS
        or Lambda would be one thing, but running it locally at home could allow
        even cooler "smart home" interactions based on email. And for IMAP servers
        that don't have great rules processing, you can kind of add that function.
        Perhaps this could even be used to act as an "agent" of the user, automating
        and performing more complex actions that users might take.
    </section>

    <section>
        <h1><a id="http-less" href="#http-less"><code>less</code> for HTTP</a></h1>
        Less, for large HTTP-addressable objects (including AWS S3)
        Progressive loading and viewing of very large files
        And progressive listing of very large directories.
        Text, multiple encodings, mine type, and hex viewer
    </section>

    <section>
        <h1><a id="axis-sender" href="#axis-sender">AXIS IP sender</a></h1>
        AXIS IP cameras record video to local storage, which is hard to access remotely.
        They can send still images over HTTP, but those are hard to work with.
        Imagine if there was a cool HTTP endpoint that could receive images from an AXIS
        IP camera and group them into sequences and render them into video or animated
        GIFs and identify the interesting keyframes and then trigger Slack integrations
        or whatever else.
    </section>

    <section>
        <h1><a id="sharegeo" href="#sharegeo">Sharegeo</a></h1>
        Just a simple website that allows you to share your location with other people.
        Either one quick share, or for a longer period of time. Like activities of a couple
        hours up to a day, semi-realtime sharing of location. So you could have like a group
        bike ride and see where everyone is. Or even longer-term recording, so you can record
        your trip through countries and so on. And then provide people with their own GPX
        if they want it. And also use end-to-end encryption to implement a zero-trust solution
        that makes it impossible for the server to see the actual location data that is being
        sent between clients.

        This is related to my other idea for an Open GPX tracker:
        A Strava-like fitness tracking app that sends your GPX to a custom webhook or email address.

        Also related to my other GPS idea:
        I want to map out how good/bad my cell service is along the skytrain route, and
        use that to go hassle my cell phone provider. (Except it turns out that GPS inside tunnels
        is also unreliable... so probably a lot of data massage needed.)
    </section>

    <section>
        <h1><a id="http-health" href="#http-health">http.health</a></h1>
        <ul>
            <li>Content base checks</li>
            <li>Positive and negative tests</li>
            <li>Custom response codes</li>
            <li>HTTP authentication</li>
            <li>TLS certificate expiration checking</li>
            <li>Expose the health endpoint for the service itself</li>
            <li>ï¿¼ escalate to SMS and phone call because iOS limits on push notifications</li>
            <li>Oauth workflow</li>
            <li>S3 Bucket privacy</li>
            <li>Multiple AWS regions</li>
            <li>SLA breach events</li>
            <li>Custom time window for evaluation of uptime availability</li>
            <li>RSS feed</li>
            <li>Slack integration</li>
            <li>Dead man switch checking aka heartbeat or push check</li>
            <li>Repeating alerts</li>
            <li>API key for...</li>
            <li>Terraform provider</li>
            <li>Read only API key</li>
            <li>Custom status page, different internal and external names</li>
            <li>Notes field or runbook URL</li>
            <li>Email alerting</li>
            <li>Precedence and roll up during major events</li>
            <li>Maintenance window</li>
            <li>Like pingdom but better</li>
        </ul>
    </section>

    <section>
        <h1><a id="rdap-whois" href="#rdap-whois">RDAP-whois for iOS/Android</a></h1>
        RDAP is a protocol that's like WHOIS but better and easier to implement.
        I bet I could make a really nice domain lookup app for iOS.
    </section>

    <section>
        <h1>STV .BLT file analyzer</h1>
        .BLT ballot file analyzer
    </section>

    <section>
        <h1>Failure-in-a-can</h1>
        The worst behaved app ever, for testing infrastructure.
        Customize failure with command line arguments or a config file.
        Distributed as a pre-made docker container on hub
    </section>

    <section>
        <h1>Slack add-ons</h1>
        <ul>
            <li>Remove unused emoji</li>
            <li>Capture logs (even from free organizations!)</li>
            <li>Identify channels that are mostly redundant based on similar audience groups.</li>
            <li>Reminder when sun is at a certain position in the sky, so that it lines up
            with roads or streets, that way you can leave the office for a few minutes to glimpse
            then sun instead of it always being hidden behind skyscrapers.</li>
            <li>Webhook filter. Add footer that allows unsubscribe, modify, assign?
                Can bundle and delay messages
                Rate limiting
                Addressing specific users based on rules
                Temporary transient mute rules
                Routine announcements about quantity of muted messages
                Mirror to a different system
                Implement as a Lambda
                Add comments to kinds of events
            </li>
        </ul>
    </section>

    <section>
        <h1>AWS add-ons</h1>
        <ul>
            <li>Estimated GHG and energy impact based on AWS historic billing data</li>
            <li>command-line resource lookup (input is arn or resource ID; output is resource details and linked resources)</li>
        </ul>
    </section>

    <section>
        <h1>Jira/Slack integration</h1>
        Auto close slack channel when associated Jira epic has been completed
    </section>

    <section>
        <h1>Stream Management System</h1>
        An event filtering platform
        Like strapi but for information flow instead of static content
        Receive from RabbitMQ or SQS or EventBridge
        How does this compare to that tool for HL7 events?
        Visual programming?
        Tests and filtering
        Forward events to slack, pagerduty, email, elastic search, SNS, SQS
        How compare to IFTTT?
        Like log stash on steroids
        Event fan-out pipelines
        Back pressure and high volume?
        How compare to Riemann?
        Like a CMS... but for real-time data
        Logs
        And business events
        Integration with Jira? Create issues, or react to issues
        How to avoid short circuits?? Or at least slow them down.
        Self hosted so you can easily add your own code
        Or cloud hosted to get started easily
        React to events from slack like messages or reactions
        What about enqueueing future events? Like notify 3 months after hiring? Is this some kind of plugin? How does it relate to deferred work?
        Real-time first. Visit a page to see real time event stream.
        Auth0 events
        Event source dashboard
        Kinesis underneath? Or as an input? Event replay? What does downtime look like? What is the HA model?
        Stream processing
        Duplicate event detection? Deduication?
        Time dimension? Or just do everything in the moment without temporal context? Create "basins" that collect statistics on events matching a certain user defined pattern. Create metrics on all numerical values.
        Streaming SQL
        Sounds like WSO2
    </section>

</main>

<include src="/fragment/footer.html" />
</body>
</html>
